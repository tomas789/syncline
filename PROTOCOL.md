# Syncline Protocol Documentation

Syncline uses a custom binary protocol over WebSockets for bidirectional real-time synchronization. It relies on the [Yjs](https://yjs.dev/) framework (and its Rust port, `yrs`) to handle Conflict-free Replicated Data Types (CRDTs).

This document outlines everything necessary to implement a client that communicates with the Syncline server.

## Connection

The client must connect to the server via WebSocket:

```
ws://<server-host>:<port>/sync
```

The WebSocket must be configured to process binary data. In Javascript/Typescript, this means setting:

```javascript
websocket.binaryType = "arraybuffer";
```

## Binary Message Format

Every message exchanged between the client and the server has the following binary structure:

| Field        | Size               | Details                                                                              |
| ------------ | ------------------ | ------------------------------------------------------------------------------------ |
| `msg_type`   | 1 byte             | The type of the message (see below).                                                 |
| `doc_id_len` | 2 bytes            | The length of the `doc_id` string, encoded as an unsigned 16-bit big-endian integer. |
| `doc_id`     | `doc_id_len` bytes | The Document ID encoded as a UTF-8 string.                                           |
| `payload`    | Remaining bytes    | The message payload, typically a Yjs standard v1 encoded State Vector or Update.     |

### Message Types

There are three types of messages defined in the protocol:

- **`MSG_SYNC_STEP_1` (0x00)**
  - **Direction**: Client ➞ Server
  - **Purpose**: Sent by the client to request missing updates from the server.
  - **Payload**: The client's local Yjs Document encoded as a State Vector (`Y.encodeStateVector(doc)`).

- **`MSG_SYNC_STEP_2` (0x01)**
  - **Direction**: Server ➞ Client
  - **Purpose**: Sent by the server in response to `MSG_SYNC_STEP_1`, containing any updates the client is missing.
  - **Payload**: A Yjs Document update (`Y.encodeStateAsUpdate(doc, stateVector)` equivalent).

- **`MSG_UPDATE` (0x02)**
  - **Direction**: Bidirectional (Client ➞ Server, Server ➞ Client)
  - **Purpose**: Disseminates newly applied changes to the document.
  - **Payload**: A Yjs Document update.

## Client Implementation Guidelines

To correctly synchronize documents with the server, a client should follow this lifecycle for each document:

### 1. Initialization and Connection

- Maintain an individual Yjs Document (`Y.Doc`) for each `doc_id` you want to sync.
- Wait for the WebSocket connection to establish (`onopen` event).

### 2. Initial Synchronization

Once connected, the client should synchronize its local state with the server:

- Generate a State Vector of the local document: `sv = Y.encodeStateVector(doc)`.
- Send a `MSG_SYNC_STEP_1` containing `sv` to the server.
- _(Optional but recommended for offline resilience)_ Send the client's current full local state as a `MSG_UPDATE` so the server can integrate any offline changes generated by the client. This is achieved by generating an update against an empty state vector: `update = Y.encodeStateAsUpdate(doc)` and sending it via `MSG_UPDATE`.

### 3. Handling Remote Updates

The client needs to listen for incoming WebSocket messages (`onmessage`).

- Parse the incoming binary buffer into `msg_type`, `doc_id`, and `payload`.
- If the `doc_id` matches a locally tracked document:
  - If the `msg_type` is `MSG_SYNC_STEP_2` or `MSG_UPDATE`:
    - Apply the `payload` to the local Yjs Document using `Y.applyUpdate(doc, payload)`.
    - _Note: You must ensure you do not re-broadcast this applied update back to the server (e.g., pause local update observers or check flags before transmitting)._

### 4. Broadcasting Local Changes

When the local document is modified by the user (or the application layer):

- The Yjs Document will emit an `update` event (`doc.on('update', (update, origin) => { ... })`).
- If the update originated locally (not from the WebSocket), dispatch a `MSG_UPDATE` with the event's `update` buffer to the server.

## Schema & Special Documents

Syncline defines standard structures for its documents over Yjs.

### The Index Document (`__index__`)

The server and clients use a special reserved document ID `__index__` to track the list of all synchronized files in the workspace.

- **`doc_id`**: `"__index__"`
- **Schema**: Contains a single Yjs Map named `"files"` (`doc.getMap('files')`).
- **Data**:
  - Keys are the file paths/names.
  - Values are simply `"1"` (or any placeholder truthy value).
  - When a file is created, it is inserted into the `files` map. When deleted, it is removed from the `files` map.

### File Documents

For normal user files, the `doc_id` is the unique file path/identifier.

- **Schema**: Contains a single Yjs Text named `"content"` (`doc.getText('content')`).
- **Data**: This text instance holds the entire valid contents of the text file. Syncing this Yjs Text guarantees real-time collaborative text editing.
